# ğŸš¨ Exception Handling (tryâ€“catch) in Declarative Pipeline

### Beginner Friendly Explanation

---

## ğŸ“Œ What is Exception Handling?

**Exception handling** means:

> â€œIf something goes wrong, donâ€™t stop suddenly.
> Handle the problem properly and inform the team.â€

In Jenkins pipeline, we use:

```
try { }
catch { }
```

* **try** â†’ run the normal steps
* **catch** â†’ run when something fails

---

## ğŸ§  Real-Life Analogy

ğŸš— **Driving a car**

* try â†’ Drive normally
* catch â†’ If tire punctures, stop safely and call mechanic

ğŸ‘‰ You donâ€™t crash the car; you handle the issue.

---

## â“ Why Do We Need Exception Handling in CI/CD?

Without tryâ€“catch:
âŒ Pipeline fails suddenly
âŒ No clear error message
âŒ Team does not know what failed

With tryâ€“catch:
âœ” Pipeline knows which stage failed
âœ” Sends email notification
âœ” Failure is handled gracefully

---

## ğŸ” Why `script {}` Is Required?

Declarative pipeline is **strict and structured**.

To use:

* try
* catch
* loops
* if-else

ğŸ‘‰ We must write them inside:

```
script {
   // Groovy code
}
```

ğŸ§  Analogy
ğŸ“¦ Special box for advanced logic

---

## ğŸ§© How Your Pipeline Handles Exceptions (Stage by Stage)

---

## ğŸ”¹ 1ï¸âƒ£ ContinuousDownload Stage

### What happens normally?

* Jenkins downloads source code from GitHub

### try block

âœ” Git clone happens

### catch block

âŒ If Git fails (repo down / network issue)
âœ” Email is sent:

```
download failed from git
```

ğŸ§  Analogy
ğŸ“¦ If delivery truck doesnâ€™t arrive â†’ send alert

---

## ğŸ”¹ 2ï¸âƒ£ ContinuousBuild Stage

### What happens?

* Maven builds the project

### try block

âœ” `mvn package` runs

### catch block

âŒ Build fails (compile error)
âœ” Email sent:

```
artifact failed
```

ğŸ§  Analogy
ğŸ³ Cooking failed â†’ inform kitchen manager

---

## ğŸ”¹ 3ï¸âƒ£ ContinuousDeployment (Test Server)

### What happens?

* WAR file copied to QA server

### try block

âœ” `scp` deploys app

### catch block

âŒ Server down / permission issue
âœ” Email sent:

```
failed to deploy in the test server
```

ğŸ§  Analogy
ğŸšš Goods couldnâ€™t reach warehouse â†’ send alert

---

## ğŸ”¹ 4ï¸âƒ£ ContinuousTesting Stage

### What happens?

* Download testing code
* Run Selenium tests

### try block

âœ” Tests run successfully

### catch block

âŒ Tests fail
âœ” Email sent:

```
failed to deploy in testing server
```

ğŸ§  Analogy
ğŸ§ª Product quality test failed â†’ report issue

---

## ğŸ”¹ 5ï¸âƒ£ ContinuousDelivery (Production)

### What happens?

* WAR file deployed to production

### try block

âœ” Production deployment

### catch block

âŒ Deployment fails
âœ” Email sent:

```
CD failed
```

ğŸ§  Analogy
ğŸ­ Final product delivery failed â†’ urgent alert

---

## ğŸ” What Happens After catch?

* Pipeline marks stage as **failed**
* Email notification is sent
* Team can take action quickly

ğŸ‘‰ Pipeline does **not crash silently**

---

## ğŸ“§ Why Email in catch Block?

* Immediate notification
* Faster troubleshooting
* Clear failure reason

ğŸ§  Analogy
ğŸ“ Emergency call when something goes wrong

---

## âš ï¸ Important Notes (Interview Tip)

âœ” tryâ€“catch works **inside script block only**
âœ” Each stage has **separate error handling**
âœ” Good for **production pipelines**
âœ” Improves reliability & visibility

---

## âœ… One-Line Interview Answer

**Exception handling in Jenkins pipeline uses tryâ€“catch blocks to safely handle failures, send alerts, and prevent sudden pipeline crashesâ€”just like handling problems calmly instead of panicking.**

---


# Example declarative pipeline with Exception Handling try and catch
```bash
pipeline{
    agent any
    stages{
        stage('ContinuosDownload'){
            steps{
                script{
                    try{
                        git  'https://github.com/thej950/maven.git'
                    }
                    catch(Exception e1){
                        mail bcc: '', body: 'download failed from git', cc: '', from: '', replyTo: '', subject: 'CI failed ', to: 'thej.devops@gmail.com'
                    }
                }
            }
        }
        stage('ContinuosBuild'){
            steps{
                script{
                    try{
                        sh 'mvn package'
                    }
                    catch(Exception e2){
                        mail bcc: '', body: 'artifact failed to ', cc: '', from: '', replyTo: '', subject: 'CI failed ', to: 'thej.devops@gmail.com'
                    }
                }
            }
        }
        stage('ContinuosDeployment'){
            steps{
                script{
                    try{
                         sh '''scp /var/lib/jenkins/workspace/declarative-pipeline/webapp/target/webapp.war ubuntu@172.31.42.1:/var/lib/tomcat9/webapps/hello.war'''
                    }
                    catch(Exception e3){
                        mail bcc: '', body: 'failed to deploy in the test server', cc: '', from: '', replyTo: '', subject: 'CI failed ', to: 'thej.devops@gmail.com'
                    }
                }
            }
        }
        stage('ContinuosTesting'){
            steps{
                script{
                    try{
                        git 'https://github.com/thej950/FunctionalTesting.git'
                        sh 'java -jar /var/lib/jenkins/workspace/declarative-pipeline/testing.jar'
                    }
                    catch(Exception e4){
                        mail bcc: '', body: 'failed to deploy in testing server', cc: '', from: '', replyTo: '', subject: 'CI failed ', to: 'thej.devops@gmail.com'
                    }
                }
            }
        }
        stage('ContinuosDelivery'){
            steps{
                script{
                    try{
                        sh '''scp /var/lib/jenkins/workspace/declarative-pipeline/webapp/target/webapp.war ubuntu@172.31.32.133:/var/lib/tomcat9/webapps/prodapp.war'''
                    }
                    catch(Exception e5){
                        mail bcc: '', body: 'failed to delivery in the production servers ', cc: '', from: '', replyTo: '', subject: 'CD failed ', to: 'thej.devops@gmail.com'
                    }
                }
            }
        }
    }
}
```

# ğŸ”¥ tryâ€“catch vs `post { failure }` in Jenkins Pipeline

---

## ğŸ“Œ Basic Meaning

| Feature    | tryâ€“catch                       | post { failure }                             |
| ---------- | ------------------------------- | -------------------------------------------- |
| Purpose    | Handle error **inside a stage** | Handle failure **after stage/pipeline ends** |
| Control    | Very fine control               | General control                              |
| Where used | Inside `script {}`              | Outside stages                               |
| Style      | Imperative (Groovy)             | Declarative (clean)                          |

---

## ğŸ§  Real-Life Analogy

### ğŸš— tryâ€“catch

> If your car breaks **during the drive**, you stop immediately and fix it.

### ğŸ post { failure }

> After reaching destination, you check if the trip had problems and report them.

---

## ğŸ”¹ 1ï¸âƒ£ tryâ€“catch (Stage-level handling)

### âœ… What it does

* Catches error **immediately**
* Allows custom action
* Can continue pipeline if needed

### ğŸ§ª Example

```groovy
stage('Build') {
  steps {
    script {
      try {
        sh 'mvn package'
      } catch (Exception e) {
        echo 'Build failed'
        mail to: 'team@gmail.com',
             subject: 'Build Failed',
             body: 'Maven build error'
      }
    }
  }
}
```

### âœ” Advantages

* Custom message per stage
* Immediate action
* Can skip or continue pipeline

### âŒ Disadvantages

* More code
* Less clean
* Needs `script {}`

---

## ğŸ”¹ 2ï¸âƒ£ post { failure } (Pipeline-level handling)

### âœ… What it does

* Runs **after stage or pipeline fails**
* Clean and simple
* No `script {}` required

### ğŸ§ª Example

```groovy
pipeline {
  agent any
  stages {
    stage('Build') {
      steps {
        sh 'mvn package'
      }
    }
  }
  post {
    failure {
      mail to: 'team@gmail.com',
           subject: 'Pipeline Failed',
           body: 'Please check Jenkins'
    }
  }
}
```

### âœ” Advantages

* Clean syntax
* Centralized error handling
* Easy to maintain

### âŒ Disadvantages

* No stage-specific logic
* Runs only after failure
* Less control

---

## ğŸ†š Side-by-Side Comparison

| Feature               | tryâ€“catch       | post { failure }        |
| --------------------- | --------------- | ----------------------- |
| Error handling timing | Immediate       | After failure           |
| Scope                 | Per stage       | Whole pipeline or stage |
| Custom messages       | âœ” Yes           | âŒ Limited               |
| Code complexity       | High            | Low                     |
| Best for              | Critical stages | Notifications           |

---

## ğŸ† Best Practice (Real Projects)

âœ… **Use BOTH together**

### âœ” tryâ€“catch

* Critical stages (Build, Deploy)
* Custom handling
* Rollback logic

### âœ” post { failure }

* Global notifications
* Cleanup
* Logs

---

## ğŸ§  Combined Example (Recommended)

```groovy
stage('Deploy') {
  steps {
    script {
      try {
        sh 'deploy.sh'
      } catch (e) {
        echo 'Deployment failed'
        currentBuild.result = 'FAILURE'
        throw e
      }
    }
  }
}

post {
  failure {
    mail to: 'devops@gmail.com',
         subject: 'Pipeline Failed',
         body: 'Check Jenkins logs'
  }
}
```

---

## ğŸ¯ Interview Ready Answer (Short)

**tryâ€“catch handles errors immediately inside a stage with custom logic, while `post { failure }` handles failures globally after the pipeline or stage ends. In real projects, we use tryâ€“catch for critical steps and post failure for centralized notifications.**

---
w
# ğŸ”” Jenkins `post` Conditions Explained Simply

`post {}` is used to run **extra actions after a pipeline or stage finishes**.

Think of it as **â€œafter work rulesâ€** ğŸ§¹ğŸ“¢

---

## ğŸ§  Real-Life Analogy (Office)

| Jenkins  | Real Life                                    |
| -------- | -------------------------------------------- |
| success  | Work completed perfectly â†’ send appreciation |
| unstable | Work done but with warnings â†’ inform team    |
| failure  | Work failed â†’ alert manager                  |
| always   | End of day â†’ clean desk no matter what       |

---

## ğŸ”¹ 1ï¸âƒ£ `post { success }`

### âœ… What it means

* Runs **ONLY if everything is successful**
* No errors
* No failed tests

### ğŸ§ª Example

```groovy
post {
  success {
    echo 'Build and deployment successful'
    mail to: 'team@gmail.com',
         subject: 'SUCCESS',
         body: 'Pipeline completed successfully'
  }
}
```

### ğŸ“Œ Use case

âœ” Notify team
âœ” Trigger next job
âœ” Tag release

---

## ğŸ”¹ 2ï¸âƒ£ `post { unstable }`

### âœ… What it means

* Pipeline completed
* BUT **some issues**
* Example: test failures, warnings

### ğŸ§ª Example

```groovy
post {
  unstable {
    echo 'Pipeline is unstable'
    mail to: 'qa@gmail.com',
         subject: 'UNSTABLE BUILD',
         body: 'Some tests failed'
  }
}
```

### ğŸ“Œ When pipeline becomes UNSTABLE

* Test failures
* `unstable()` step
* Test reports with failed cases

---

## ğŸ”¹ 3ï¸âƒ£ `post { failure }`

### âœ… What it means

* Pipeline **FAILED**
* One or more stages crashed

### ğŸ§ª Example

```groovy
post {
  failure {
    echo 'Pipeline failed'
    mail to: 'devops@gmail.com',
         subject: 'PIPELINE FAILED',
         body: 'Immediate attention required'
  }
}
```

### ğŸ“Œ Use case

ğŸš¨ Alerts
ğŸš¨ Rollback
ğŸš¨ Incident ticket

---

## ğŸ”¹ 4ï¸âƒ£ `post { always }`

### âœ… What it means

* Runs **every time**
* Success or failure or unstable

### ğŸ§ª Example

```groovy
post {
  always {
    echo 'Cleaning workspace'
    cleanWs()
  }
}
```

### ğŸ“Œ Use case

ğŸ§¹ Cleanup
ğŸ“Š Archive logs
ğŸ“ Delete temp files

---

## ğŸ†š Summary Table

| Condition | Runs When               |
| --------- | ----------------------- |
| success   | Everything passed       |
| unstable  | Completed with warnings |
| failure   | Pipeline failed         |
| always    | Every time              |

---

## ğŸ§  Full Example (Real Project Style)

```groovy
pipeline {
  agent any
  stages {
    stage('Build') {
      steps {
        sh 'mvn package'
      }
    }
    stage('Test') {
      steps {
        sh 'mvn test'
      }
    }
  }
  post {
    success {
      mail to: 'team@gmail.com',
           subject: 'SUCCESS',
           body: 'Build OK'
    }
    unstable {
      mail to: 'qa@gmail.com',
           subject: 'UNSTABLE',
           body: 'Test failures found'
    }
    failure {
      mail to: 'devops@gmail.com',
           subject: 'FAILED',
           body: 'Pipeline failed'
    }
    always {
      cleanWs()
    }
  }
}
```

---

## ğŸ¯ Interview-Ready Answer

**post conditions are used to run actions after pipeline execution. `success` runs when everything passes, `unstable` runs when there are warnings like test failures, `failure` runs when pipeline crashes, and `always` runs every time for cleanup and reports.**

---
